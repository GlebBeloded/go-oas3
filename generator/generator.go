package generator

import (
	"fmt"
	"strings"

	"github.com/ahmetb/go-linq"
	"github.com/dave/jennifer/jen"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/spf13/cast"

	"github.com/mikekonan/go-oas3/configurator"
)

type Generator struct {
	normalizer *Normalizer          `di.inject:"normalizer"`
	filler     *TypeFiller          `di.inject:"typeFiller"`
	config     *configurator.Config `di.inject:"config"`
}

type Result struct {
	ComponentsCode *jen.File
	RouterCode     *jen.File
}

func (generator *Generator) file(from jen.Code, packagePath string) *jen.File {
	file := jen.NewFilePathName(packagePath, generator.trimPackagePath(packagePath))
	file.HeaderComment("This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")

	file.Add(from)

	return file
}

func (generator *Generator) Generate(swagger *openapi3.Swagger) *Result {
	return &Result{
		ComponentsCode: generator.file(generator.components(swagger), generator.config.ComponentsPackagePath),
		RouterCode: generator.file(jen.Null().
			Add(generator.wrappers(swagger)).
			Add(jen.Line()).
			Add(generator.requestResponseBuilders(swagger)), generator.config.PackagePath),
	}
}

func (generator *Generator) requestBody(name string, requestBody *openapi3.RequestBodyRef) (result jen.Code) {
	if requestBody == nil {
		return jen.Null()
	}

	requestBodyName := name + "RequestBody"
	result = jen.Type().Id(requestBodyName)

	if requestBody.Value != nil && len(requestBody.Value.Content) > 0 && requestBody.Value.Content["application/json"].Schema != nil {
		var schema = requestBody.Value.Content["application/json"].Schema
		generator.filler.fillGoType(result.(*jen.Statement), requestBodyName, schema)
	}

	return
}

func (generator *Generator) responsesBodies(name string, suffix string, responsesBody map[string]*openapi3.ResponseRef) (result []jen.Code) {
	linq.From(responsesBody).
		SelectT(func(kv linq.KeyValue) jen.Code {
			responseBody := kv.Value.(*openapi3.ResponseRef)
			if responseBody == nil || responseBody.Value == nil || len(responseBody.Value.Content) == 0 || responseBody.Value.Content["application/json"].Schema == nil {
				return jen.Null()
			}

			bodyName := name + cast.ToString(kv.Key) + suffix
			result := jen.Type().Id(bodyName)
			var schema = responseBody.Value.Content["application/json"].Schema
			generator.filler.fillGoType(result, bodyName, schema)

			return result
		}).
		ToSlice(&result)

	return
}

func (generator *Generator) requestParameters(paths map[string]*openapi3.PathItem) jen.Code {
	var result []jen.Code

	linq.From(paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			operationsCodeTags := map[string][]jen.Code{}

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				GroupByT(
					func(kv linq.KeyValue) string { return kv.Value.(*openapi3.Operation).Tags[0] },
					func(kv linq.KeyValue) (result []jen.Code) {
						name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
						operation := kv.Value.(*openapi3.Operation)
						if operation.RequestBody == nil {
							result = append(result, generator.requestParameterStruct(name, "", false, operation))
							return
						}

						if operation.RequestBody != nil && len(operation.RequestBody.Value.Content) == 1 {
							contentType := cast.ToString(linq.From(operation.RequestBody.Value.Content).SelectT(func(kv linq.KeyValue) string { return cast.ToString(kv.Key) }).First())
							result = append(result, generator.requestParameterStruct(name, contentType, false, operation))
							return
						}

						var contentTypeResult []jen.Code
						linq.From(operation.RequestBody.Value.Content).
							SelectT(func(kv linq.KeyValue) jen.Code { return generator.requestParameterStruct(name, cast.ToString(kv.Key), true, operation) }).
							ToSlice(&contentTypeResult)

						result = append(result, contentTypeResult...)

						result = generator.normalizer.doubleLineAfterEachElement(result...)

						return
					},
				).
				ToMapByT(&operationsCodeTags,
					func(kv linq.Group) interface{} { return kv.Key },
					func(kv linq.Group) (grouped []jen.Code) {
						linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
						return
					},
				)

			return linq.From(operationsCodeTags)
		}).
		GroupByT(
			func(kv linq.KeyValue) interface{} { return kv.Key },
			func(kv linq.KeyValue) interface{} { return kv.Value },
		).
		SelectT(func(kv linq.Group) jen.Code {
			var grouped []jen.Code
			linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
			return jen.Add(generator.normalizer.lineAfterEachElement(grouped...)...)
		}).
		ToSlice(&result)

	return jen.Null().
		Add(result...).
		Add(jen.Line())
}

func (generator *Generator) components(swagger *openapi3.Swagger) jen.Code {
	var componentsResult []jen.Code

	linq.From(swagger.Components.Schemas).
		WhereT(func(kv linq.KeyValue) bool { return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) == 0 }). //filter enums
		SelectT(func(kv linq.KeyValue) jen.Code {
			schemaRef := kv.Value.(*openapi3.SchemaRef)
			return generator.objectFromSchema(cast.ToString(kv.Key), schemaRef)
		},
		).ToSlice(&componentsResult)

	var componentsFromPathsResult []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			componentsByName := map[string]jen.Code{}

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				WhereT(func(kv linq.KeyValue) bool {
					operation := kv.Value.(*openapi3.Operation)
					return operation.RequestBody != nil && len(operation.RequestBody.Value.Content) > 0 &&
						linq.From(operation.RequestBody.Value.Content).
							AnyWithT(func(kv linq.KeyValue) bool { return kv.Value.(*openapi3.MediaType).Schema.Ref == "" })
				}).
				SelectManyT(
					func(kv linq.KeyValue) linq.Query {
						result := map[string]jen.Code{}
						name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
						operation := kv.Value.(*openapi3.Operation)

						if len(operation.RequestBody.Value.Content) == 1 {
							name += "RequestBody"
							obj := linq.From(operation.RequestBody.Value.Content).SelectT(func(kv linq.KeyValue) interface{} { return kv.Value }).First().(*openapi3.MediaType)

							result[name] = generator.objectFromSchema(name, obj.Schema)
							return linq.From(result)
						}

						linq.From(operation.RequestBody.Value.Content).
							ToMapByT(&result,
								func(kv linq.KeyValue) string { return name + generator.normalizer.contentType(cast.ToString(kv.Key)+"RequestBody") },
								func(kv linq.KeyValue) jen.Code {
									meType := kv.Value.(*openapi3.MediaType)

									objName := name + generator.normalizer.contentType(cast.ToString(kv.Key)+"RequestBody")
									return generator.objectFromSchema(objName, meType.Schema)
								})

						return linq.From(result)
					},
				).
				ToMapByT(&componentsByName,
					func(kv linq.KeyValue) interface{} { return kv.Key },
					func(kv linq.KeyValue) interface{} { return kv.Value })

			return linq.From(componentsByName)
		}).
		GroupByT(
			func(kv linq.KeyValue) interface{} { return kv.Key },
			func(kv linq.KeyValue) interface{} { return kv.Value },
		).
		SelectT(func(kv linq.Group) jen.Code {
			var grouped []jen.Code
			linq.From(kv.Group).ToSlice(&grouped)
			return jen.Add(generator.normalizer.doubleLineAfterEachElement(grouped...)...)
		}).
		ToSlice(&componentsFromPathsResult)

	componentsResult = generator.normalizer.lineAfterEachElement(componentsResult...)
	componentsFromPathsResult = generator.normalizer.lineAfterEachElement(componentsFromPathsResult...)

	return jen.Null().
		Add(componentsResult...).
		Add(jen.Line()).
		Add(componentsFromPathsResult...).
		Add(jen.Line()).
		Add(generator.enums(swagger)).
		Add(jen.Line())
}

func (generator *Generator) requestParameterStruct(name string, contentType string, appendContentTypeToName bool, operation *openapi3.Operation) jen.Code {
	type parameter struct {
		In   string
		Code jen.Code
	}

	var additionalParameters []parameter

	if contentType != "" {
		if appendContentTypeToName {
			name += generator.normalizer.contentType(contentType)
		}

		bodyTypeName := generator.normalizer.extractNameFromRef(operation.RequestBody.Value.Content[contentType].Schema.Ref)
		if bodyTypeName == "" {
			bodyTypeName = name + "RequestBody"
		}

		additionalParameters = append(additionalParameters, parameter{In: "Body", Code: jen.Id("Body").
			Qual(generator.config.ComponentsPackagePath, bodyTypeName)})
	}

	var parameters []jen.Code

	linq.From(operation.Parameters).
		GroupByT(
			func(parameter *openapi3.ParameterRef) string { return parameter.Value.In },
			func(parameter *openapi3.ParameterRef) *openapi3.ParameterRef { return parameter }).
		SelectT(
			func(group linq.Group) (parameter parameter) {
				var structFields []jen.Code
				linq.From(group.Group).
					OrderByT(func(parameter *openapi3.ParameterRef) string { return parameter.Value.Name }).
					SelectT(func(parameter *openapi3.ParameterRef) (result jen.Code) {
						name := generator.normalizer.normalizeName(parameter.Value.Name)
						var statement = jen.Id(name)

						if len(parameter.Value.Schema.Value.Enum) > 0 {
							if len(parameter.Value.Schema.Ref) > 0 {
								generator.filler.fillGoType(statement, generator.normalizer.extractNameFromRef(parameter.Value.Schema.Ref), parameter.Value.Schema)
								return statement
							}

							//todo: generate enum for anonymous type
						}

						generator.filler.fillGoType(statement, name, parameter.Value.Schema)
						return statement
					}).
					ToSlice(&structFields)

				parameter.In = cast.ToString(group.Key)
				parameter.Code = jen.Id(generator.normalizer.normalizeName(cast.ToString(group.Key))).Struct(structFields...)

				return
			}).
		Concat(linq.From(additionalParameters)).
		OrderByT(func(parameter parameter) string { return parameter.In }).
		SelectT(func(parameter parameter) jen.Code { return parameter.Code }).
		ToSlice(&parameters)

	return jen.Type().Id(name + "Request").Struct(parameters...)
}

func (generator *Generator) enumFromSchema(name string, schema *openapi3.SchemaRef) jen.Code {
	if len(schema.Ref) > 0 {
		return jen.Null()
	}

	var result []jen.Code
	var enumValues []jen.Code

	result = append(result, jen.Type().Id(generator.normalizer.normalizeName(name)).String())

	linq.From(schema.Value.Enum).SelectT(func(value string) jen.Code {
		return jen.Var().Id(name + generator.normalizer.normalizeName(strings.Title(value))).Id(name).Op("=").Lit(value)
	}).ToSlice(&enumValues)

	var enumSwitchCases []jen.Code

	linq.From(schema.Value.Enum).SelectT(func(value string) jen.Code {
		return jen.Id(name + generator.normalizer.normalizeName(strings.Title(value)))
	}).ToSlice(&enumSwitchCases)

	result = append(result, enumValues...)

	result = append(result, jen.Func().Params(
		jen.Id("enum").Id(name)).Id("Check").Params().Params(
		jen.Id("error")).Block(
		jen.Switch(jen.Id("enum")).Block(
			jen.Case(enumSwitchCases...).Block(
				jen.Return().Id("nil"))),
		jen.Return().Qual("fmt",
			"Errorf").Call(jen.Lit("invalid Color enum value")),
	).Add(jen.Line()))

	result = append(result, jen.Func().Params(
		jen.Id("enum").Op("*").Id(name)).Id("UnmarshalJSON").Params(
		jen.Id("data").Index().Id("byte")).Params(
		jen.Id("error")).Block(
		jen.Var().Id("strValue").Id("string"),
		jen.If(jen.Id("err").Op(":=").Qual("encoding/json",
			"Unmarshal").Call(jen.Id("data"),
			jen.Op("&").Id("strValue")),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Return().Id("err")),
		jen.Id("enumValue").Op(":=").Id(name).Call(jen.Id("strValue")),
		jen.If(jen.Id("err").Op(":=").Id("enumValue").Dot("Check").Call(),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Return().Id("err")),
		jen.Op("*").Id("enum").Op("=").Id("enumValue"),
		jen.Return().Id("nil"),
	))

	result = generator.normalizer.lineAfterEachElement(result...)

	return jen.Null().Add(result...).Add(jen.Line())
}

func (generator *Generator) objectFromSchema(name string, schema *openapi3.SchemaRef) *jen.Statement {
	name = generator.normalizer.normalizeName(name)
	typeDeclaration := jen.Type().Id(name)

	if len(schema.Value.Properties) == 0 {
		if len(schema.Value.Enum) > 0 {
			generator.filler.fillGoType(typeDeclaration, name+"Enum", schema)
			return typeDeclaration
		}

		typeDeclaration.Interface()
		return typeDeclaration
	}

	return typeDeclaration.Struct(generator.typeProperties(name, schema.Value)...)
}

func (generator *Generator) typeProperties(typeName string, schema *openapi3.Schema) (parameters []jen.Code) {
	linq.From(schema.Properties).
		OrderByT(func(kv linq.KeyValue) interface{} { return kv.Key }).
		SelectT(func(kv linq.KeyValue) interface{} {
			originName := cast.ToString(kv.Key)
			name := generator.normalizer.normalizeName(originName)
			parameter := jen.Id(name)
			schemaRef := kv.Value.(*openapi3.SchemaRef)
			if len(schemaRef.Value.Enum) > 0 {
				name = typeName + strings.Title(name) + "Enum"
			}

			generator.filler.fillGoType(parameter, name, schemaRef)
			generator.filler.fillJsonTag(parameter, originName)
			return parameter
		}).ToSlice(&parameters)

	return
}

func (generator *Generator) enums(swagger *openapi3.Swagger) jen.Code {
	var pathsResult []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			var result []jen.Code
			path := cast.ToString(kv.Key)

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectManyT(func(kv linq.KeyValue) linq.Query {
					var requestBodyResults []jen.Code

					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					operation := kv.Value.(*openapi3.Operation)

					if operation.RequestBody != nil {
						linq.From(operation.RequestBody.Value.Content).
							SelectT(func(kv linq.KeyValue) jen.Code {
								schema := kv.Value.(*openapi3.MediaType).Schema

								namePrefix := generator.normalizer.normalizeName(name + generator.normalizer.contentType(cast.ToString(kv.Key)))

								if len(schema.Value.Enum) > 0 {
									return generator.enumFromSchema(namePrefix+"RequestBodyEnum", schema)
								}

								var result []jen.Code
								linq.From(schema.Value.Properties).WhereT(func(kv linq.KeyValue) bool {
									return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) > 0
								}).SelectT(func(kv linq.KeyValue) interface{} {
									enumName := namePrefix + generator.normalizer.normalizeName(strings.Title(cast.ToString(kv.Key))) + "Enum"
									enumName = generator.normalizer.normalizeName(enumName)
									return generator.enumFromSchema(enumName, kv.Value.(*openapi3.SchemaRef))
								}).ToSlice(&result)

								return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
							}).ToSlice(&requestBodyResults)
					}

					var result []jen.Code
					linq.From(operation.Responses).
						SelectManyT(func(kv linq.KeyValue) linq.Query {
							return linq.From(kv.Value.(*openapi3.ResponseRef).Value.Content).
								SelectT(func(kv linq.KeyValue) jen.Code {
									schema := kv.Value.(*openapi3.MediaType).Schema
									namePrefix := generator.normalizer.normalizeName(name + generator.normalizer.contentType(cast.ToString(kv.Key)))

									if len(schema.Value.Enum) > 0 {
										return generator.enumFromSchema(namePrefix+"ResponseBodyEnum", schema)
									}

									var result []jen.Code
									linq.From(schema.Value.Properties).WhereT(func(kv linq.KeyValue) bool {
										return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) > 0
									}).SelectT(func(kv linq.KeyValue) interface{} {
										enumName := namePrefix + generator.normalizer.normalizeName(strings.Title(cast.ToString(kv.Key))) + "Enum"
										enumName = generator.normalizer.normalizeName(enumName)
										return generator.enumFromSchema(enumName, kv.Value.(*openapi3.SchemaRef))
									}).ToSlice(&result)

									return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
								})
						}).
						Concat(linq.From(requestBodyResults)).
						ToSlice(&result)

					return linq.From(result)
				}).ToSlice(&result)

			return linq.From(result)
		}).ToSlice(&pathsResult)

	var componentsResult []jen.Code

	linq.From(swagger.Components.Schemas).
		SelectT(func(kv linq.KeyValue) jen.Code {
			namePrefix := generator.normalizer.normalizeName(cast.ToString(kv.Key))
			schema := kv.Value.(*openapi3.SchemaRef)

			if len(schema.Value.Enum) > 0 {
				return generator.enumFromSchema(namePrefix, schema)
			}

			var result []jen.Code
			linq.From(schema.Value.Properties).WhereT(func(kv linq.KeyValue) bool {
				return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) > 0
			}).SelectT(func(kv linq.KeyValue) interface{} {
				enumName := namePrefix + generator.normalizer.normalizeName(strings.Title(cast.ToString(kv.Key))) + "Enum"
				enumName = generator.normalizer.normalizeName(enumName)
				return generator.enumFromSchema(enumName, kv.Value.(*openapi3.SchemaRef))
			}).ToSlice(&result)

			return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
		}).ToSlice(&componentsResult)

	return jen.Null().Add(generator.normalizer.lineAfterEachElement(pathsResult...)...).Add(generator.normalizer.lineAfterEachElement(componentsResult...)...)
}

func (generator *Generator) hooksStruct() jen.Code {
	return jen.Type().Id("Hooks").Struct(
		jen.Id("UnmarshalFailedHook").Func().Params(jen.Qual("net/http",
			"ResponseWriter"),
			jen.Op("*").Qual("net/http",
				"Request"),
			jen.Id("string"),
			jen.Id("error")),
		jen.Id("MarshalFailedHook").Func().Params(jen.Qual("net/http",
			"ResponseWriter"),
			jen.Op("*").Qual("net/http",
				"Request"),
			jen.Id("string"),
			jen.Id("error")),
		jen.Id("HeaderParseFailedHook").Func().Params(jen.Qual("net/http",
			"ResponseWriter"),
			jen.Op("*").Qual("net/http",
				"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("error")),
		jen.Id("PathParseFailedHook").Func().Params(jen.Qual("net/http",
			"ResponseWriter"),
			jen.Op("*").Qual("net/http",
				"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("error")),
		jen.Id("QueryParseFailedHook").Func().Params(jen.Qual("net/http",
			"ResponseWriter"),
			jen.Op("*").Qual("net/http",
				"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("error")),
		jen.Id("WriteBodyFailedHook").Func().Params(jen.Qual("net/http",
			"ResponseWriter"),
			jen.Op("*").Qual("net/http",
				"Request"),
			jen.Id("string"),
			jen.Id("int"),
			jen.Id("error")),
	).Add(jen.Line())
}

func (generator *Generator) wrappers(swagger *openapi3.Swagger) jen.Code {
	var results []jen.Code

	linq.From(generator.groupedOperations(swagger)).
		SelectT(func(groupedOperations groupedOperations) jen.Code {
			tag := cast.ToString(groupedOperations.tag)

			var routes []jen.Code
			linq.From(groupedOperations.operations).
				SelectT(func(operation operationWithPath) jen.Code {
					method := generator.normalizer.normalizeName(strings.Title(strings.ToLower(cast.ToString(operation.method))))

					if operation.operation.RequestBody == nil || len(operation.operation.RequestBody.Value.Content) == 1 {
						name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method))
						return jen.Id("router").Dot("router").Dot(method).Call(jen.Lit(operation.path), jen.Id("router").Dot(name))
					}

					var result []jen.Code
					linq.From(operation.operation.RequestBody.Value.Content).
						SelectT(func(kv linq.KeyValue) jen.Code {
							name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method)) + generator.normalizer.contentType(cast.ToString(kv.Key))
							return jen.Id("router").Dot("router").Dot(method).Call(jen.Lit(operation.path), jen.Id("router").Dot(name))
						}).ToSlice(&result)

					return jen.Add(generator.normalizer.lineAfterEachElement(result...)...)
				}).ToSlice(&routes)

			var wrappers []jen.Code

			linq.From(groupedOperations.operations).
				SelectT(func(operation operationWithPath) jen.Code {
					method := generator.normalizer.normalizeName(strings.Title(strings.ToLower(cast.ToString(operation.method))))
					routerName := strings.ToLower(tag) + "Router"

					if operation.operation.RequestBody == nil {
						name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method))
						requestName := name + "Request"
						return generator.wrapperFunc(name, requestName, routerName, method, operation.path, operation.operation, nil, "")
					}
					if len(operation.operation.RequestBody.Value.Content) == 1 {
						name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method))
						requestName := name + "Request"
						requestBody := linq.From(operation.operation.RequestBody.Value.Content).SelectT(func(kv linq.KeyValue) interface{} { return kv.Value }).First().(*openapi3.MediaType).Schema
						return generator.wrapperFunc(name, requestName, routerName, method, operation.path, operation.operation, requestBody, "")
					}

					var result []jen.Code
					linq.From(operation.operation.RequestBody.Value.Content).
						SelectT(func(kv linq.KeyValue) interface{} {
							name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method)) + generator.normalizer.contentType(cast.ToString(kv.Key))
							requestName := name + "Request"
							requestBody := operation.operation.RequestBody.Value.Content[cast.ToString(kv.Key)].Schema
							return generator.wrapperFunc(name, requestName, routerName, method, operation.path, operation.operation, requestBody, cast.ToString(kv.Key))
						}).
						ToSlice(&result)

					return jen.Add(generator.normalizer.lineAfterEachElement(result...)...)
				}).ToSlice(&wrappers)

			return jen.Null().
				Add(generator.handler(tag+"Handler", tag+"Service", strings.ToLower(tag)+"Router")).
				Add(jen.Line()).
				Add(generator.router(strings.ToLower(tag)+"Router", tag+"Service")).
				Add(jen.Line()).
				Add(jen.Func().Params(jen.Id("router").Op("*").Id(strings.ToLower(tag) + "Router")).Id("mount").Params().Block(generator.normalizer.lineAfterEachElement(routes...)...)).
				Add(jen.Line()).
				Add(generator.normalizer.lineAfterEachElement(wrappers...)...).
				Add(jen.Line())

		}).ToSlice(&results)

	return jen.Null().
		Add(generator.hooksStruct()).
		Add(jen.Line()).
		Add(generator.normalizer.lineAfterEachElement(results...)...).
		Add(jen.Line())
}

type groupedOperations struct {
	tag        string
	operations []operationWithPath
}

type operationWithPath struct {
	method    string
	operation *openapi3.Operation
	path      string
}

func (generator *Generator) groupedOperations(swagger *openapi3.Swagger) []groupedOperations {
	var result []groupedOperations

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)

			return linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) groupedOperations {
					operation := kv.Value.(*openapi3.Operation)
					tag := operation.Tags[0]

					return groupedOperations{
						tag:        tag,
						operations: []operationWithPath{{operation: operation, path: path, method: cast.ToString(kv.Key)}},
					}
				})
		}).
		GroupByT(
			func(wrapper groupedOperations) string { return wrapper.tag },
			func(wrapper groupedOperations) groupedOperations { return wrapper }).
		SelectT(func(group linq.Group) groupedOperations {
			var operations []operationWithPath

			linq.From(group.Group).
				SelectT(func(wrapper groupedOperations) operationWithPath { return wrapper.operations[0] }).ToSlice(&operations)

			return groupedOperations{
				tag:        cast.ToString(group.Key),
				operations: operations,
			}
		}).
		ToSlice(&result)

	return result
}

func (generator *Generator) handler(name string, serviceName string, routerName string) jen.Code {
	return jen.Func().Id(name).Params(
		jen.Id("impl").Id(serviceName),
		jen.Id("r").Qual("github.com/go-chi/chi", "Router"),
		jen.Id("hooks").Op("*").Id("Hooks")).Params(
		jen.Qual("net/http",
			"Handler")).Block(
		jen.Id("router").Op(":=").Op("&").Id(routerName).Values(jen.Id("router").Op(":").Id("r"),
			jen.Id("service").Op(":").Id("impl"),
			jen.Id("hooks").Op(":").Id("hooks")),
		jen.Id("router").Dot("mount").Call(),
		jen.Return().Id("router").Dot("router"),
	)
}

func (generator *Generator) router(routerName string, serviceName string) jen.Code {
	return jen.Type().Id(routerName).Struct(
		jen.Id("router").Qual("github.com/go-chi/chi", "Router"),
		jen.Id("service").Id(serviceName),
		jen.Id("hooks").Op("*").Id("Hooks"),
	)
}

func (generator *Generator) wrapperPathParsers(wrapperName string, operation *openapi3.Operation) (result []jen.Code) {
	linq.From(operation.Parameters).
		GroupByT(
			func(parameter *openapi3.ParameterRef) string { return parameter.Value.In },
			func(parameter *openapi3.ParameterRef) *openapi3.ParameterRef { return parameter },
		).
		SelectManyT(func(group linq.Group) linq.Query {
			return linq.From(group.Group).SelectT(func(parameter *openapi3.ParameterRef) jen.Code {
				in := parameter.Value.In
				name := generator.normalizer.normalizeName(parameter.Value.Name)
				paramName := in + name
				if len(parameter.Value.Schema.Value.Enum) > 0 { //TODO: support anonymous enum types
					enumType := generator.normalizer.extractNameFromRef(parameter.Value.Schema.Ref)
					return generator.wrapperEnum(in, enumType, name, paramName, wrapperName, parameter)
				}

				if parameter.Value.Schema.Value.Format == "uuid" {
					return generator.wrapperUUID(in, name, paramName, wrapperName, parameter)
				}

				return generator.wrapperStr(in, name, paramName, wrapperName, parameter)
			})
		}).ToSlice(&result)

	return generator.normalizer.lineAfterEachElement(result...)
}

func (generator *Generator) wrapperUUID(in string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Id("uuid").Dot("Parse").Call(jen.Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name))))
	case "query":
		result = result.Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Id("uuid").Dot("Parse").Call(jen.Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name))))
	case "path":
		result = result.Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Id("uuid").Dot("Parse").Call(jen.Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name))))
	default:
		panic("unsupported " + in + " type")
	}

	result = result.Add(jen.Line())

	return result.
		Add(jen.If(jen.Id("err").Op("!=").Id("nil")).
			Block(jen.Id("router").Dot("hooks").Dot(strings.Title(in)+"ParseFailedHook").Call(jen.Id("w"),
				jen.Id("r"),
				jen.Lit(wrapperName),
				jen.Lit(parameter.Value.Name),
				jen.Id("err")),
				jen.Return())).
		Add(jen.Line()).
		Add(jen.Id("request").Dot(strings.Title(in)).Dot(name).Op("=").Id(paramName)).
		Add(jen.Line())
}

func (generator *Generator) wrapperEnum(in string, enumType string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.Id(paramName).Op(":=").Id(enumType).Call(jen.Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name))))
	case "query":
		result = result.Add(jen.Id(paramName).Op(":=").Id(enumType).Call(jen.Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name))))
	case "path":
		result = result.Add(jen.Id(paramName).Op(":=").Id(enumType).Call(jen.Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name))))
	default:
		panic("unsupported " + in + " type")
	}

	return result.
		Add(jen.Line()).
		Add(jen.If(jen.Id("err").Op(":=").Id(paramName).Dot("Check").Call(),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.If(jen.Id("router").Dot("hooks").Dot(strings.Title(in)+"ParseFailedHook").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot(strings.Title(in)+"ParseFailedHook").Call(jen.Id("w"),
					jen.Id("r"),
					jen.Lit(wrapperName),
					jen.Lit(parameter.Value.Name),
					jen.Id("err"))),
			jen.Return())).
		Add(jen.Line()).
		Add(jen.Id("request").Dot(strings.Title(parameter.Value.In)).Dot(name).Op("=").Id(paramName)).
		Add(jen.Line())
}

func (generator *Generator) wrapperStr(in string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.Id(paramName).Op(":=").Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "query":
		result = result.Add(jen.Id(paramName).Op(":=").Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "path":
		result = result.Add(jen.Id(paramName).Op(":=").Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name)))
	default:
		panic("unsupported " + in + " type")
	}

	if parameter.Value.Required {
		result = result.
			Add(jen.Line()).
			Add(jen.If(jen.Id(paramName).Op("==").Lit("")).Block(
				jen.If(jen.Id("router").Dot("hooks").Dot(strings.Title(in)+"ParseFailedHook").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot(strings.Title(in)+"ParseFailedHook").Call(jen.Id("w"),
						jen.Id("r"),
						jen.Lit(wrapperName),
						jen.Lit(parameter.Value.Name),
						jen.Qual("fmt",
							"Errorf").Call(jen.Lit(fmt.Sprintf("%s is empty", parameter.Value.Name))))),
				jen.Return())).
			Add(jen.Line())
	}

	return result.
		Add(jen.Line()).
		Add(jen.Id("request").Dot(strings.Title(parameter.Value.In)).Dot(name).Op("=").Id(paramName)).
		Add(jen.Line())
}

func (generator *Generator) wrapperBody(method string, path string, contentType string, wrapperName string, operation *openapi3.Operation, body *openapi3.SchemaRef) jen.Code {
	result := jen.Null()

	if operation.RequestBody == nil {
		return result
	}

	name := generator.normalizer.extractNameFromRef(body.Ref)

	if name == "" {
		name = generator.normalizer.normalizeOperationName(path, method) + generator.normalizer.contentType(cast.ToString(contentType)) + "RequestBody"
	}

	return result.
		Add(jen.Var().Id("body").Id(name)).
		Add(jen.Line()).
		Add(jen.If(jen.Id("err").Op(":=").Qual("encoding/json",
			"NewDecoder").Call(jen.Id("r").Dot("Body")).Dot("Decode").Call(jen.Op("&").Id("body")),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.If(jen.Id("router").Dot("hooks").Dot("UnmarshalFailedHook").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("UnmarshalFailedHook").Call(jen.Id("w"),
					jen.Id("r"),
					jen.Lit(wrapperName),
					jen.Id("err")),
				jen.Return()),
			jen.Return())).
		Add(jen.Line()).
		Add(jen.Id("request").Dot("Body").Op("=").Id("body")).
		Add(jen.Line())
}

func (generator *Generator) wrapperFunc(name string, requestName string, routerName, method string, path string, operation *openapi3.Operation, requestBody *openapi3.SchemaRef, contentType string) jen.Code {
	funcCode := []jen.Code{
		jen.Id("request").Op(":=").Id(requestName).Values(),
	}

	funcCode = append(funcCode, generator.wrapperPathParsers(name, operation)...)
	funcCode = append(funcCode, generator.wrapperBody(method, path, contentType, name, operation, requestBody)) //TODO: support different content-types

	funcCode = append(funcCode, jen.Id("response").Op(":=").Id("router").Dot("service").Dot(name).Call(jen.Id("r").Dot("Context").Call(),
		jen.Id("request")),
		jen.For(jen.List(jen.Id("header"),
			jen.Id("value")).Op(":=").Range().Id("response").Dot("headers").Call()).Block(
			jen.Id("w").Dot("Header").Call().Dot("Set").Call(jen.Id("header"),
				jen.Id("value"))))

	if len(operation.Responses) > 0 && linq.From(operation.Responses).AnyWithT(func(kv linq.KeyValue) bool { return len(kv.Value.(*openapi3.ResponseRef).Value.Content) > 0 }) {
		funcCode = append(funcCode, jen.If(jen.Id("len").Call(jen.Id("response").Dot("contentType").Call()).Op(">").Lit(0)).Block(
			jen.Id("w").Dot("Header").Call().Dot("Set").Call(jen.Lit("content-type"),
				jen.Id("response").Dot("contentType").Call())))

		funcCode = append(funcCode, jen.If(jen.Id("response").Dot("body").Call().Op("!=").Id("nil")).Block(
			jen.List(jen.Id("data"),
				jen.Id("err")).Op(":=").Qual("encoding/json",
				"Marshal").Call(jen.Id("response").Dot("body").Call()),
			jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
				jen.If(jen.Id("router").Dot("hooks").Dot("MarshalFailedHook").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("MarshalFailedHook").Call(jen.Id("w"),
						jen.Id("r"),
						jen.Lit(name),
						jen.Id("err"))),
				jen.Return()),
			jen.If(jen.List(jen.Id("count"),
				jen.Id("err")).Op(":=").Id("w").Dot("Write").Call(jen.Id("data")),
				jen.Id("err").Op("!=").Id("nil")).Block(
				jen.If(jen.Id("router").Dot("hooks").Dot("WriteBodyFailedHook").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("WriteBodyFailedHook").Call(jen.Id("w"),
						jen.Id("r"),
						jen.Lit(name),
						jen.Id("count"),
						jen.Id("err"))),
				jen.Return())))

	}

	funcCode = append(funcCode, jen.Id("w").Dot("WriteHeader").Call(jen.Id("response").Dot("statusCode").Call()))

	return jen.Func().Params(
		jen.Id("router").Op("*").Id(routerName)).Id(name).Params(
		jen.Id("w").Qual("net/http",
			"ResponseWriter"),
		jen.Id("r").Op("*").Qual("net/http", "Request")).
		Block(funcCode...)
}

func (generator *Generator) requestResponseBuilders(swagger *openapi3.Swagger) jen.Code {
	result := []jen.Code{
		generator.responseStruct(),
		generator.handlersTypes(swagger),
		generator.builders(swagger),
		generator.handlersInterfaces(swagger),
		generator.requestParameters(swagger.Paths),
	}

	result = generator.normalizer.doubleLineAfterEachElement(result...)

	return jen.Null().Add(result...)
}

type operationResponse struct {
	ContentTypeBodyNameMap map[string]string
	Headers                map[string]*openapi3.HeaderRef
	StatusCode             string
}

type operationStruct struct {
	Tag                   string
	Name                  string
	RequestName           string
	ResponseName          string
	Responses             []operationResponse
	InterfaceResponseName string
	PrivateName           string
}

func (generator *Generator) builders(swagger *openapi3.Swagger) (result jen.Code) {
	var builders []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			var operationStructs []operationStruct

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) operationStruct {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					operation := kv.Value.(*openapi3.Operation)
					var operationResponses []operationResponse

					linq.From(operation.Responses).
						SelectT(func(kv linq.KeyValue) (response operationResponse) {
							response.ContentTypeBodyNameMap = map[string]string{}
							response.Headers = kv.Value.(*openapi3.ResponseRef).Value.Headers

							linq.From(kv.Value.(*openapi3.ResponseRef).Value.Content).
								ToMapByT(&response.ContentTypeBodyNameMap,
									func(kv linq.KeyValue) string { return cast.ToString(kv.Key) },
									func(kv linq.KeyValue) (structName string) {
										if "" == kv.Value.(*openapi3.MediaType).Schema.Ref {
											structName = name
											structName += strings.Title(generator.normalizer.normalizeName(cast.ToString(kv.Key)))
											return structName
										}

										structName = generator.normalizer.extractNameFromRef(kv.Value.(*openapi3.MediaType).Schema.Ref)
										return
									})

							response.StatusCode = cast.ToString(kv.Key)

							return
						}).ToSlice(&operationResponses)

					return operationStruct{
						Tag:                   operation.Tags[0],
						Name:                  name,
						PrivateName:           generator.normalizer.decapitalize(name),
						RequestName:           name + "Request",
						InterfaceResponseName: name + "Response",
						ResponseName:          generator.normalizer.decapitalize(name + "Response"),
						Responses:             operationResponses,
					}
				}).ToSlice(&operationStructs)

			return linq.From(operationStructs)
		}).
		SelectT(func(operationStruct operationStruct) jen.Code { return generator.responseBuilders(operationStruct) }).
		ToSlice(&builders)

	return jen.Null().Add(builders...)
}

func (generator *Generator) handlersTypes(swagger *openapi3.Swagger) jen.Code {
	var result []jen.Code

	linq.From(swagger.Paths).
		SelectT(func(kv linq.KeyValue) jen.Code {
			path := cast.ToString(kv.Key)
			var result []jen.Code

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) jen.Code {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(generator.responseType(name))...)
				}).ToSlice(&result)

			result = generator.normalizer.doubleLineAfterEachElement(result...)

			return jen.Null().Add(result...)
		}).ToSlice(&result)

	result = generator.normalizer.doubleLineAfterEachElement(result...)
	return jen.Null().Add(result...)
}

func (generator *Generator) handlersInterfaces(swagger *openapi3.Swagger) jen.Code {
	var result []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(
			func(kv linq.KeyValue) linq.Query {
				path := cast.ToString(kv.Key)
				taggedInterfaceMethods := map[string][]jen.Code{}

				linq.From(kv.Value.(*openapi3.PathItem).Operations()).
					GroupByT(func(kv linq.KeyValue) string { return kv.Value.(*openapi3.Operation).Tags[0] },
						func(kv linq.KeyValue) []jen.Code {
							name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
							operation := kv.Value.(*openapi3.Operation)

							if operation.RequestBody == nil {
								return []jen.Code{jen.Id(name).Params(jen.Qual("context", "Context"), jen.Id(name+"Request")).Params(jen.Id(name + "Response"))}
							}

							//if we have only one content type we dont need to have it inside function name
							if len(operation.RequestBody.Value.Content) == 1 {
								return []jen.Code{jen.Id(name).Params(jen.Qual("context", "Context"), jen.Id(name+"Request")).Params(jen.Id(name + "Response"))}
							}

							var contentTypedInterfaceMethods []jen.Code
							linq.From(operation.RequestBody.Value.Content).
								SelectT(func(kv linq.KeyValue) jen.Code {
									contentTypedName := name + generator.normalizer.contentType(cast.ToString(kv.Key))
									return jen.Id(contentTypedName).Params(jen.Qual("context", "Context"), jen.Id(contentTypedName+"Request")).Params(jen.Id(name + "Response"))
								}).ToSlice(&contentTypedInterfaceMethods)

							return contentTypedInterfaceMethods
						}).
					ToMapByT(&taggedInterfaceMethods,
						func(kv linq.Group) interface{} { return kv.Key },
						func(kv linq.Group) (grouped []jen.Code) {
							linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
							return
						},
					)

				return linq.From(taggedInterfaceMethods)
			}).
		GroupByT(
			func(kv linq.KeyValue) interface{} { return kv.Key },
			func(kv linq.KeyValue) interface{} { return kv.Value },
		).
		SelectT(func(kv linq.Group) jen.Code {
			var grouped []jen.Code
			linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
			return jen.Type().Id(cast.ToString(kv.Key) + "Service").Interface(grouped...)
		}).
		ToSlice(&result)

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
}

func (generator *Generator) responseStruct() jen.Code {
	return jen.Type().Id("response").Struct(
		jen.Id("statusCode").Id("int"),
		jen.Id("body").Interface(),
		jen.Id("contentType").Id("string"),
		jen.Id("headers").Map(jen.Id("string")).Id("string"),
	).Add(jen.Line()).
		Add(jen.Type().Id("responseInterface").Interface(
			jen.Id("statusCode").Params().Id("int"),
			jen.Id("body").Params().Interface(),
			jen.Id("contentType").Params().Id("string"),
			jen.Id("headers").Params().Map(jen.Id("string")).Id("string")))
}

func (generator *Generator) responseInterface(name string) jen.Code {
	name = generator.normalizer.decapitalize(name)

	return jen.Type().Id(name + "Response").Interface(jen.Id(name + "Response").Params())
}

func (generator *Generator) responseType(name string) jen.Code {
	decapicalizedName := generator.normalizer.decapitalize(name)
	capitalizedName := strings.Title(name)

	interfaceDeclaration := jen.Type().Id(capitalizedName+"Response").Interface(
		jen.Id("responseInterface"),
		jen.Id(decapicalizedName+"Response").Params(),
	)

	declaration := jen.Type().Id(decapicalizedName + "Response").Struct(jen.Id("response"))
	interfaceImplementation := jen.Func().Params(jen.Id(decapicalizedName+"Response")).Id(decapicalizedName+"Response").Params().Block().
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("statusCode").Params().Params(
			jen.Id("int")).Block(
			jen.Return().Id("response").Dot("response").Dot("statusCode"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("body").Params().Params(jen.Interface()).Block(
			jen.Return().Id("response").Dot("response").Dot("body"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("contentType").Params().Params(
			jen.Id("string")).Block(
			jen.Return().Id("response").Dot("response").Dot("contentType"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName + "Response")).Id("headers").Params().Params(
			jen.Map(jen.Id("string")).Id("string")).Block(
			jen.Return().Id("response").Dot("response").Dot("headers"),
		))

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(interfaceDeclaration, declaration, interfaceImplementation)...)
}

func (generator *Generator) responseImplementationFunc(name string) jen.Code {
	return jen.Func().Params(jen.Id(strings.Title(name) + "Response")).Id(generator.normalizer.decapitalize(name) + "Response").Params().Block()
}

//if hasHeaders && hasContentTypes
//N statusCode -> headersStruct -> M contentType -> body -> assemble

//if hasHeaders && !hasContentTypes
//N statusCode -> headersStruct -> assemble

//if !hasHeaders && hasContentTypes
//N statusCode -> M contentType -> body -> assemble

//if !hasHeaders && !hasContentTypes
//N statusCode -> assemble
func (generator *Generator) responseBuilders(operationStruct operationStruct) jen.Code {
	builderConstructorName := generator.builderConstructorName(operationStruct.Name)
	statusCodesBuilderName := generator.statusCodesBuilderName(operationStruct.PrivateName)

	structBuilder := jen.Type().Id(statusCodesBuilderName).Struct(jen.Id("response"))
	structConstructor := jen.Func().Id(builderConstructorName).Params().Params(
		jen.Op("*").Id(statusCodesBuilderName)).Block(
		jen.Return().Id("new").Call(jen.Id(statusCodesBuilderName)),
	)

	var results []jen.Code

	linq.From(operationStruct.Responses).
		SelectT(func(resp operationResponse) (results []jen.Code) {
			hasHeaders := len(resp.Headers) > 0
			hasContentTypes := len(resp.ContentTypeBodyNameMap) > 0

			//OK
			if !hasHeaders && !hasContentTypes {
				//assembler struct
				assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode)
				results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

				//statusCode -> assembler
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(assemblerName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//build
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
					jen.Id(operationStruct.InterfaceResponseName)).Block(
					jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
				)

				return
			}

			if hasHeaders && !hasContentTypes {
				headersStructName := generator.headersStructName(operationStruct.Name + resp.StatusCode)
				results = append(results, generator.headersStruct(headersStructName, resp.Headers))
				headersBuilderName := generator.headersBuilderName(operationStruct.PrivateName + resp.StatusCode)

				//headers struct
				results = append(results, generator.headersStruct(headersStructName, resp.Headers))

				//statusCode -> headersStruct
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(headersBuilderName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Return().Op("&").Id(headersBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//headersStruct struct
				results = append(results, jen.Type().Id(headersBuilderName).Struct(jen.Id("response")))

				assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode)

				//headers -> assemble
				results = append(results,
					jen.Func().Params(
						jen.Id("builder").Op("*").Id(headersBuilderName)).Id("Headers").Params(
						jen.Id("headers").Id(headersStructName)).Params(
						jen.Op("*").Id(assemblerName)).Block(
						jen.Id("builder").Dot("headers").Op("=").Id("headers").Dot("toMap").Call(),
						jen.Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
					))

				//assembler struct
				results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

				//assemble
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
					jen.Id(operationStruct.InterfaceResponseName)).Block(
					jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
				)

				return
			}

			if !hasHeaders && hasContentTypes {
				contentTypeBuilderName := generator.contentTypeBuilderName(operationStruct.PrivateName + resp.StatusCode)

				//statusCode -> contentType
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(contentTypeBuilderName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Return().Op("&").Id(contentTypeBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//content-type struct
				results = append(results, jen.Type().Id(contentTypeBuilderName).Struct(jen.Id("response")))

				var contentTypeBodyBuild []jen.Code

				//content-types -> body -> build
				linq.From(resp.ContentTypeBodyNameMap).
					SelectT(func(kv linq.KeyValue) jen.Code {
						var result []jen.Code

						contentType := cast.ToString(kv.Key)
						contentTypeFuncName := generator.contentTypeFuncName(contentType)
						bodyBuilderName := generator.bodyGeneratorName(operationStruct.PrivateName+resp.StatusCode, contentType)

						//content-type -> body
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(contentTypeBuilderName)).Id(contentTypeFuncName).Params().Params(
							jen.Op("*").Id(bodyBuilderName)).Block(
							jen.Id("builder").Dot("response").Dot("contentType").Op("=").Lit(contentType),
							jen.Return().Op("&").Id(bodyBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//body struct
						result = append(result, jen.Type().Id(bodyBuilderName).Struct(jen.Id("response")))

						assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode + generator.normalizer.contentType(contentType))

						//body builder
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(bodyBuilderName)).Id("Body").Params(
							jen.Id("body").Qual(generator.config.ComponentsPackagePath, cast.ToString(kv.Value))).Params(
							jen.Op("*").Id(assemblerName)).Block(
							jen.Id("builder").Dot("response").Dot("body").Op("=").Id("body"),
							jen.Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//assembler struct
						results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

						//assemble
						results = append(results, jen.Func().Params(
							jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
							jen.Id(operationStruct.InterfaceResponseName)).Block(
							jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
						)

						return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
					}).ToSlice(&contentTypeBodyBuild)

				results = generator.normalizer.doubleLineAfterEachElement(append(results, contentTypeBodyBuild...)...)

				return
			}

			if hasHeaders && hasContentTypes {
				headersStructName := generator.headersStructName(operationStruct.Name + resp.StatusCode)
				headersBuilderName := generator.headersBuilderName(operationStruct.PrivateName + resp.StatusCode)

				//statusCode -> headers
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(headersBuilderName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Return().Op("&").Id(headersBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//headers struct
				results = append(results, generator.headersStruct(headersStructName, resp.Headers))

				//headers builder struct
				results = append(results, jen.Type().Id(headersBuilderName).Struct(jen.Id("response")))

				//headers -> content-type
				contentTypeBuilderName := generator.contentTypeBuilderName(operationStruct.PrivateName + resp.StatusCode)
				results = append(results,
					jen.Func().Params(
						jen.Id("builder").Op("*").Id(headersBuilderName)).Id("Headers").Params(
						jen.Id("headers").Id(headersStructName)).Params(
						jen.Op("*").Id(contentTypeBuilderName)).Block(
						jen.Id("builder").Dot("headers").Op("=").Id("headers").Dot("toMap").Call(),
						jen.Return().Op("&").Id(contentTypeBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
					))

				//content-type struct
				results = append(results, jen.Type().Id(contentTypeBuilderName).Struct(jen.Id("response")))

				var contentTypeBodyBuild []jen.Code

				//content-types -> body -> build
				linq.From(resp.ContentTypeBodyNameMap).
					SelectT(func(kv linq.KeyValue) jen.Code {
						var result []jen.Code

						contentType := cast.ToString(kv.Key)
						contentTypeFuncName := generator.contentTypeFuncName(contentType)
						bodyBuilderName := generator.bodyGeneratorName(operationStruct.PrivateName+resp.StatusCode, contentType)

						//content-type -> body
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(contentTypeBuilderName)).Id(contentTypeFuncName).Params().Params(
							jen.Op("*").Id(bodyBuilderName)).Block(
							jen.Id("builder").Dot("response").Dot("contentType").Op("=").Lit(contentType),
							jen.Return().Op("&").Id(bodyBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//body struct
						result = append(result, jen.Type().Id(bodyBuilderName).Struct(jen.Id("response")))

						assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode + generator.normalizer.contentType(contentType))

						//body builder
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(bodyBuilderName)).Id("Body").Params(
							jen.Id("body").Qual(generator.config.ComponentsPackagePath, cast.ToString(kv.Value))).Params(
							jen.Op("*").Id(assemblerName)).Block(
							jen.Id("builder").Dot("response").Dot("body").Op("=").Id("body"),
							jen.Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//assembler struct
						results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

						//assemble
						results = append(results, jen.Func().Params(
							jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
							jen.Id(operationStruct.InterfaceResponseName)).Block(
							jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
						)

						return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
					}).ToSlice(&contentTypeBodyBuild)

				results = generator.normalizer.doubleLineAfterEachElement(append(results, contentTypeBodyBuild...)...)
			}
			return
		}).
		SelectManyT(func(builders []jen.Code) linq.Query { return linq.From(builders) }).
		ToSlice(&results)

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(append([]jen.Code{structBuilder, structConstructor}, results...)...)...)
}

func (generator *Generator) headersStruct(name string, headers map[string]*openapi3.HeaderRef) jen.Code {
	if len(headers) == 0 {
		return jen.Null()
	}

	var headersCode []jen.Code

	linq.From(headers).SelectT(func(kv linq.KeyValue) jen.Code {
		name := generator.normalizer.normalizeName(cast.ToString(kv.Key))
		field := jen.Id(name)

		generator.filler.fillGoType(field, name, kv.Value.(*openapi3.HeaderRef).Value.Schema)

		return field
	}).ToSlice(&headersCode)

	headersStruct := jen.Type().Id(name).Struct(headersCode...)

	var headersMapCode []jen.Code

	linq.From(headers).SelectT(func(kv linq.KeyValue) jen.Code {
		name := generator.normalizer.normalizeName(cast.ToString(kv.Key))
		return jen.Lit(name).Op(":").Qual("github.com/spf13/cast", "ToString").Call(jen.Id("headers").Dot(name))
	}).ToSlice(&headersMapCode)

	headersToMap := jen.Func().Params(
		jen.Id("headers").Id(name)).Id("toMap").Params().Params(
		jen.Map(jen.Id("string")).Id("string")).Block(
		jen.Return().Map(jen.Id("string")).Id("string").
			Values(headersMapCode...))

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(headersStruct, headersToMap)...)
}

func (*Generator) builderConstructorName(name string) string {
	return name + "ResponseBuilder"
}

func (*Generator) statusCodesBuilderName(name string) string {
	return name + "StatusCodeResponseBuilder"
}

func (*Generator) headersBuilderName(name string) string {
	return name + "HeadersBuilder"
}

func (*Generator) headersStructName(name string) string {
	return name + "Headers"
}

func (*Generator) assemblerName(name string) string {
	return name + "ResponseBuilder"
}

func (generator *Generator) contentTypeBuilderName(name string) string {
	return name + "ContentTypeBuilder"
}

func (generator *Generator) contentTypeFuncName(contentType string) string {
	return generator.normalizer.contentType(contentType)
}

func (generator *Generator) bodyGeneratorName(name string, contentType string) string {
	return name + generator.normalizer.contentType(contentType) + "BodyBuilder"
}

func (generator *Generator) trimPackagePath(from string) string {
	index := strings.LastIndex(from, "/")
	if index < 0 {
		return from
	}

	return from[index+1:]
}
